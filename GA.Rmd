---
title: "GA"
author: "Diego Gij√≥n"
date: "2025-05-29"
output: html_document
---

## Optimizaci√≥n de la Funci√≥n de Rastrigin con Algoritmos Gen√©ticos en R

Este proyecto trata sobre el uso de algoritmos gen√©ticos (una t√©cnica de inteligencia artificial inspirada en la evoluci√≥n biol√≥gica) para resolver un problema matem√°tico. El problema es encontrar el valor m√≠nimo de una funci√≥n matem√°tica llamada funci√≥n de Rastrigin, la cual es dif√≠cil de resolver porque tiene muchos "enga√±os", es decir, muchos m√≠nimos locales. Esto hace que los m√©todos tradicionales de b√∫squeda se queden atascados en puntos incorrectos. Los algoritmos gen√©ticos ayudan a explorar el espacio de soluciones de manera m√°s eficiente, imitando procesos como la selecci√≥n natural, la mutaci√≥n y el cruce gen√©tico.

```{r}
library(GA)
```

Aqu√≠ se carga una librer√≠a de R llamada GA, que contiene funciones listas para implementar algoritmos gen√©ticos. Sin esta librer√≠a, no podr√≠amos usar los comandos necesarios para aplicar este tipo de algoritmo.

### Definici√≥n de la Funci√≥n de Rastrigin

La funci√≥n de Rastrigin es una funci√≥n no convexa utilizada como prueba para algoritmos de optimizaci√≥n. Tiene un m√≠nimo global en el origen y muchos m√≠nimos locales, lo que la convierte en un desaf√≠o para los m√©todos de optimizaci√≥n.

En este bloque de c√≥digo se define la funci√≥n de Rastrigin. Esta funci√≥n toma como entrada un vector de n√∫meros x, y produce como salida un valor que depende de esos n√∫meros. Cuanto menor sea el resultado, mejor es la soluci√≥n. Es importante notar que tiene una forma complicada: incluye t√©rminos cuadr√°ticos y funciones trigonom√©tricas, lo que genera un paisaje con muchas colinas y valles (m√≠nimos locales), y solo un m√≠nimo global en el punto donde todos los valores son cero.


```{r}
# Definici√≥n de la funci√≥n de Rastrigin
rastrigin <- function(x) {
  n <- length(x)
  10 * n + sum(x^2 - 10 * cos(2 * pi * x))
}
```

### Aplicaci√≥n del Algoritmo Gen√©tico

En este paso se pone en marcha el algoritmo gen√©tico. La funci√≥n ga() es la encargada de ejecutar todo el proceso.Ponemos que:

-Use n√∫meros reales (real-valued) en lugar de enteros. Utilizaremos el tipo "real-valued" ya que estamos trabajando con variables continuas. 

-Use como ‚Äúaptitud‚Äù la funci√≥n de Rastrigin, pero negada (-rastrigin(x)), porque el algoritmo maximiza por defecto, y nosotros queremos minimizar.

-Busque soluciones en el rango entre -5.12 y 5.12 (el dominio t√≠pico de esta funci√≥n).

-Use una poblaci√≥n de 50 soluciones posibles por cada generaci√≥n.

-Haga un m√°ximo de 100 iteraciones.

-Detenga el proceso si no hay mejora en 50 iteraciones seguidas.

-Este es el n√∫cleo de todo el proceso: el algoritmo va evolucionando soluciones poco a poco, buscando mejorar la ‚Äúaptitud‚Äù (es decir, encontrar valores que den un resultado m√°s bajo en la funci√≥n).



```{r}
# Aplicaci√≥n del algoritmo gen√©tico
GA_result <- ga(
  type = "real-valued",
  fitness = function(x) -rastrigin(x),  # Negamos la funci√≥n porque GA maximiza por defecto
  lower = rep(-5.12, 2),
  upper = rep(5.12, 2),
  popSize = 50,
  maxiter = 100,
  run = 50,
  pmutation = 0.2,
  seed = 123
)
```

### üìä Visualizaci√≥n de Resultados

```{r}
# Resumen de los resultados
summary(GA_result)

# Gr√°fico de la evoluci√≥n del fitness
plot(GA_result)
```
Finalmente, se muestran los resultados del algoritmo. La funci√≥n summary() imprime un resumen del mejor valor encontrado y de c√≥mo se comport√≥ el algoritmo en general. Luego, plot() genera un gr√°fico que muestra c√≥mo fue mejorando la soluci√≥n a lo largo de las generaciones. Este gr√°fico es √∫til para ver si el algoritmo encontr√≥ un buen m√≠nimo y si fue eficiente.

üîµ L√≠nea Azul (Mean)
Esta l√≠nea representa el promedio de aptitud de toda la poblaci√≥n en cada generaci√≥n. Al principio, el promedio es muy malo (valores bajos, por debajo de -30), pero mejora r√°pidamente en las primeras generaciones. Luego, oscila mucho, lo que significa que las soluciones en la poblaci√≥n var√≠an mucho en calidad. Aunque mejora un poco, tiende a estabilizarse sin llegar a la mejor soluci√≥n.

üü¢ L√≠nea Verde (Best)
Esta l√≠nea muestra la mejor soluci√≥n encontrada en cada generaci√≥n. En las primeras iteraciones, mejora muy r√°pidamente (lo cual es una buena se√±al), y despu√©s se mantiene casi constante, cerca de 0, que es el valor ideal para esta funci√≥n. Eso significa que el algoritmo encontr√≥ una excelente soluci√≥n desde temprano y la conserv√≥.

üü© √Årea Fosforita (Median)
El √°rea verde sombreada representa la mediana de la poblaci√≥n (el valor central). Ayuda a visualizar c√≥mo se distribuyen las soluciones. En este caso, se puede ver que la mayor√≠a de las soluciones est√°n lejos de la mejor, ya que hay bastante separaci√≥n entre el √°rea verde y la l√≠nea verde. Esto indica que, aunque el algoritmo encontr√≥ una soluci√≥n muy buena, no toda la poblaci√≥n convergi√≥ a ese punto.

### Conjunto de Datos: Expresi√≥n de miRNA en Tejidos Cervicales

### Preparaci√≥n del Entorno

```{r, warning=FALSE}
library(MLSeq)
library(DaMiRseq)
library(GARS)
```

## Carga y Preprocesamiento de los Datos

En esta parte del proyecto, se trabaja con un conjunto de datos real de expresi√≥n gen√©tica, espec√≠ficamente niveles de miRNA (peque√±as mol√©culas involucradas en la regulaci√≥n gen√©tica). El conjunto contiene 714 miRNAs medidos en 58 muestras: 29 tumorales y 29 no tumorales. Estos datos est√°n incluidos en un paquete de R llamado MLSeq.

Primero se carga el archivo con los datos de expresi√≥n gen√©tica. Despu√©s se define la clase de cada muestra (tumoral o no tumoral), se crea un objeto especializado para an√°lisis gen√≥mico (SummarizedExperiment), y se normalizan los datos. La normalizaci√≥n es crucial porque asegura que las comparaciones entre muestras sean justas, eliminando sesgos t√©cnicos.

```{r}
# Cargar el conjunto de datos
filepath <- system.file("extdata/cervical.txt", package = "MLSeq")
cervical <- read.table(filepath, header = TRUE)

# Crear el vector de clases
class_vector <- data.frame(class = gsub('[0-9]+', '', colnames(cervical)))
rownames(class_vector) <- colnames(cervical)

# Crear un objeto SummarizedExperiment
SE_obj <- DaMiR.makeSE(cervical, class_vector)

# Filtrar y normalizar los datos
datanorm <- DaMiR.normalization(SE_obj)
```

### Aplicaci√≥n del Algoritmo Gen√©tico para Selecci√≥n de Variables

Utilizaremos la funci√≥n `GARS_GA` del paquete `GARS` para identificar un subconjunto robusto de miRNAs que mejor discrimine entre las clases tumorales y no tumorales.

Aqu√≠ se usa el algoritmo gen√©tico GARS_GA del paquete GARS para seleccionar un subconjunto peque√±o (longitud 10) de miRNAs que discriminan mejor entre muestras tumorales y no tumorales. En lugar de explorar todos los posibles subconjuntos (lo cual ser√≠a inviable por la cantidad de combinaciones), el algoritmo evoluciona hacia las mejores combinaciones usando selecci√≥n, cruce y mutaci√≥n.

```{r}
# Crear vector de clases
class_vector <- data.frame(class = gsub('[0-9]+', '', colnames(cervical)))
rownames(class_vector) <- colnames(cervical)
classes <- class_vector$class

# Ejecutar GARS (sin modificar nada m√°s)
gars_result <- GARS_GA(data = datanorm, class = class_vector, chr.len = 10)
  
```

Variables Seleccionadas: El algoritmo identific√≥ 10 miRNAs clave que ayudan a distinguir entre tejido tumoral y no tumoral. miR-146a fue con diferencia la variable m√°s usada, apareciendo m√°s de 150,000 veces en combinaciones evaluadas. Esto indica que el algoritmo encontr√≥ que este miRNA es consistentemente √∫til para construir modelos clasificadores precisos. Le siguen miR-7 y miR-224, que tambi√©n fueron muy frecuentes, aunque en menor proporci√≥n. Otros miRNAs como miR-21* y miR-145* tambi√©n aparecen con una frecuencia alta, confirmando que son informativos para la clasificaci√≥n tumoral/no tumoral.

Evoluci√≥n del Fitness: Muestra la mejora progresiva de la calidad de los subconjuntos seleccionados.

Aplicaci√≥n Pr√°ctica: Los miRNAs encontrados podr√≠an ser biomarcadores diagn√≥sticos o terap√©uticos, √∫tiles en medicina personalizada.

### PCA

Despu√©s de ejecutar el algoritmo gen√©tico GARS_GA, obtuvimos un objeto de clase especial llamado GarsSelectedFeatures, el cual contiene los resultados del proceso evolutivo. Dentro de este objeto, encontramos que las variables (miRNAs) seleccionadas por el algoritmo no se acceden con los m√©todos t√≠picos como $ o con funciones auxiliares, sino que est√°n almacenadas como nombres de columnas dentro del slot llamado data_red. Este slot es una matriz de expresi√≥n reducida, que contiene solo los datos de los 10 miRNAs seleccionados para todas las muestras del conjunto. Para obtener los nombres de estos miRNAs, simplemente usamos la funci√≥n colnames() sobre ese slot: colnames(gars_result@data_red). Esto nos dio como resultado un vector con los nombres exactos de los miRNAs que el algoritmo determin√≥ como los m√°s relevantes para separar las clases tumorales y no tumorales.

Con estos 10 miRNAs, procedimos a extraer sus valores de expresi√≥n desde la matriz original de datos normalizados (datanorm) y a construir una nueva matriz que conten√≠a solo estas variables. Posteriormente, realizamos un An√°lisis de Componentes Principales (PCA), una t√©cnica que permite reducir la dimensionalidad de los datos para visualizarlos de forma m√°s sencilla. Al proyectar las muestras en un plano definido por las dos primeras componentes principales, obtuvimos un gr√°fico que muestra c√≥mo se agrupan las muestras seg√∫n su clase (tumoral o no tumoral). Esta visualizaci√≥n es muy √∫til, ya que si observamos una clara separaci√≥n entre ambas clases, significa que los miRNAs seleccionados por el algoritmo gen√©tico tienen un fuerte poder discriminativo, validando la calidad del proceso de selecci√≥n de variables.

```{r}
# Matriz de expresi√≥n normalizada
expr_data <- assay(datanorm)

# Obtener datos seleccionados por GA
selected_vars <- colnames(gars_result@data_red)
expr_selected <- expr_data[selected_vars, ]

# PCA
pca_result <- prcomp(t(expr_selected), scale. = TRUE)
pca_df <- data.frame(
  PC1 = pca_result$x[, 1],
  PC2 = pca_result$x[, 2],
  Class = class_vector$class
)

# Visualizaci√≥n
library(ggplot2)
ggplot(pca_df, aes(x = PC1, y = PC2, color = Class)) +
  geom_point(size = 3) +
  labs(title = "PCA con miRNAs seleccionados por GARS",
       x = "Componente Principal 1", y = "Componente Principal 2") +
  theme_minimal()


```
###  Validaci√≥n Cruzada Manual (5x2CV) con miRNAs seleccionados

Para evaluar el poder predictivo de los miRNAs seleccionados por el algoritmo gen√©tico, se implement√≥ una validaci√≥n cruzada manual siguiendo el esquema 5x2CV. Esta t√©cnica consiste en repetir cinco veces un proceso de validaci√≥n cruzada de dos particiones. En cada repetici√≥n, se divide aleatoriamente el conjunto de muestras en dos mitades: una para entrenamiento del modelo y otra para validaci√≥n. Esto se repite en ambas direcciones y luego en cinco iteraciones distintas, lo que proporciona una estimaci√≥n robusta y menos sesgada del rendimiento del modelo. Para cada divisi√≥n, se entren√≥ un modelo Random Forest y se calcul√≥ la precisi√≥n de clasificaci√≥n en la partici√≥n de prueba. Finalmente, se promediaron las diez puntuaciones resultantes para obtener la precisi√≥n media y su desviaci√≥n est√°ndar, ofreciendo una medida clara del rendimiento esperado en nuevos datos.


```{r}
library(caret)
library(ggplot2)

# Top 5 miRNAs m√°s usados seg√∫n el gr√°fico
top_vars <- c("miR-146a", "miR-7", "miR-224", "miR-145*", "miR-21*")

# Extraer sus valores de expresi√≥n desde los datos normalizados
expr_data <- assay(datanorm)
expr_selected_top <- expr_data[top_vars, ]

# Preparar el data frame para el modelo
train_data <- as.data.frame(t(expr_selected_top))
train_data$class <- as.factor(class_vector$class)

# Validaci√≥n cruzada 5x2 manual
set.seed(123)
resultados <- c()

for (rep in 1:5) {
  folds <- createFolds(train_data$class, k = 2, list = TRUE, returnTrain = TRUE)
  
  for (i in 1:2) {
    train_idx <- folds[[i]]
    test_idx <- setdiff(1:nrow(train_data), train_idx)
    
    train_fold <- train_data[train_idx, ]
    test_fold <- train_data[test_idx, ]
    
    modelo <- train(
      class ~ .,
      data = train_fold,
      method = "rf",
      trControl = trainControl(method = "none")
    )
    
    pred <- predict(modelo, newdata = test_fold)
    acc <- sum(pred == test_fold$class) / length(pred)
    resultados <- c(resultados, acc)
  }
}

# Mostrar resultados
mean_acc <- mean(resultados)
sd_acc <- sd(resultados)

cat("Precisi√≥n media usando top 5 miRNAs:", round(mean_acc, 3), "\n")
cat("Desviaci√≥n est√°ndar:", round(sd_acc, 3), "\n")

```

La validaci√≥n cruzada manual aplicada al conjunto de datos seleccionados por el algoritmo gen√©tico (GARS) arroj√≥ una precisi√≥n media del 89.7% con una desviaci√≥n est√°ndar del 3.2%. Esta precisi√≥n indica que el modelo fue capaz de clasificar correctamente la mayor√≠a de las muestras tumorales y no tumorales utilizando solo los 10 miRNAs seleccionados. Adem√°s, la baja desviaci√≥n est√°ndar sugiere que el rendimiento es estable a lo largo de las distintas particiones del conjunto de datos, lo que indica buena generalizaci√≥n y bajo riesgo de sobreajuste.